#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R3, /* reset=*/ U8X8_PIN_NONE);

// --- PIN DEFS (Permanent Solder) ---
#define ENC_TRA  2  
#define ENC_TRB  3  
#define BTN_PSH  4  
#define BTN_CON  7  
#define BTN_BAK  8  
#define BZ_OUT   5  

// --- GAME DATA ---
#define ROWS 9
#define COLS 5
#define TAC_MAX 120 
enum State { TITLE, PLAYING, SHOP, GAMEOVER };
State state = TITLE;

struct Ball { float x, y, vx, vy; bool active; };
struct Brick { bool active; int hp; bool sentinel; };
struct Projectile { float x, y; bool active; };

Ball ball;
Brick bricks[ROWS * COLS];
Projectile pulse, missile; 
int pX = 22, pW = 18;
int nuyen = 0, ballPower = 1, currentLevel = 1;
int integrity = 40, maxIntegrity = 40;
int shieldEnergy = 100;
bool shieldActive = false;
int tacCharge = 0; 
int shopIdx = 0; 
unsigned long lastSfxTime = 0;

volatile int encoderDelta = 0;
static int lastTRA = HIGH;

void readEncoder() {
  int tra = digitalRead(ENC_TRA);
  if (tra != lastTRA && tra == LOW) {
    if (digitalRead(ENC_TRB) != tra) encoderDelta += 8; 
    else encoderDelta -= 8;
  }
  lastTRA = tra;
}

void playSfx(int freq, int dur) { 
  if (millis() - lastSfxTime > 50) {
    tone(BZ_OUT, freq, dur); 
    lastSfxTime = millis();
  }
}

void generateLevel() {
  for(int i=0; i<ROWS*COLS; i++) {
    bricks[i].active = (random(0, 10) > 2);
    bricks[i].sentinel = (random(0, 10) > 8); 
    bricks[i].hp = bricks[i].sentinel ? (2 + (currentLevel / 2)) : 1; 
  }
  ball.active = false; pulse.active = false; missile.active = false;
  ball.x = 32; ball.y = 110; 
  float spd = 1.6 + (currentLevel * 0.1); 
  ball.vx = (random(0,2) == 0 ? spd : -spd);
  ball.vy = -spd; 
}

void setup() {
  pinMode(ENC_TRA, INPUT_PULLUP); pinMode(ENC_TRB, INPUT_PULLUP);
  pinMode(BTN_PSH, INPUT_PULLUP); pinMode(BTN_CON, INPUT_PULLUP);
  pinMode(BTN_BAK, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENC_TRA), readEncoder, CHANGE);
  u8g2.begin();
  generateLevel();
}

void updateGame() {
  pX = constrain(pX + encoderDelta, 0, 64 - pW);
  encoderDelta = 0; 
  
  if (tacCharge < TAC_MAX) tacCharge++;

  if (digitalRead(BTN_CON) == LOW) { state = SHOP; playSfx(600, 50); delay(250); return; }

  shieldActive = (digitalRead(BTN_BAK) == LOW && shieldEnergy > 5);
  if (shieldActive) shieldEnergy -= 2; else if (shieldEnergy < 100) shieldEnergy++;

  if (!ball.active) {
    ball.x = pX + (pW / 2); ball.y = 110;
    if (digitalRead(BTN_PSH) == LOW) { ball.active = true; playSfx(1000, 30); delay(250); }
  } else {
    if (digitalRead(BTN_PSH) == LOW && tacCharge >= TAC_MAX) {
      missile.active = true; missile.x = pX + pW/2; missile.y = 110;
      tacCharge = 0; 
      playSfx(1400, 40);
    }
  }

  if (ball.active) {
    ball.x += ball.vx; ball.y += ball.vy;
    // Sides
    if (ball.x <= 1) { ball.x = 2; ball.vx *= -1; playSfx(200, 5); }
    if (ball.x >= 62) { ball.x = 61; ball.vx *= -1; playSfx(200, 5); }
    // Ceiling Removal: Ball only bounces at the absolute top of the screen (y=0)
    if (ball.y <= 0) { ball.y = 1; ball.vy *= -1; playSfx(200, 5); }
    
    if (ball.y >= 127) { integrity -= 10; ball.active = false; playSfx(150, 200); if (integrity <= 0) state = GAMEOVER; }
    if (ball.y >= 115 && ball.y <= 118 && ball.x >= pX && ball.x <= pX + pW) {
      ball.y = 114; ball.vy *= -1; ball.vx = (ball.x - (pX + pW/2.0f)) / (pW/4.0f); playSfx(500, 10);
    }
  }

  if (missile.active) { missile.y -= 3.0; if (missile.y < 0) missile.active = false; }

  if (pulse.active) {
    pulse.y += 2.0;
    if (pulse.y > 127) pulse.active = false;
    if (pulse.y >= 115 && pulse.y <= 120 && abs(pulse.x - (pX + pW/2)) < pW/2) {
      if (!shieldActive) { integrity -= 5; playSfx(100, 100); }
      pulse.active = false;
    }
  }

  bool clear = true;
  for (int i = 0; i < ROWS * COLS; i++) {
    if (!bricks[i].active) continue;
    clear = false;
    int bx = (i % COLS) * 12 + 2; int by = (i / COLS) * 6 + 32; // Playfield start
    
    if (ball.active && ball.x > bx && ball.x < bx + 10 && ball.y > by && ball.y < by + 4) {
      bricks[i].hp -= ballPower;
      if (bricks[i].hp <= 0) { 
        bricks[i].active = false; nuyen += 50; 
        if (bricks[i].sentinel && !pulse.active) { pulse.x = bx + 5; pulse.y = by + 4; pulse.active = true; } 
      }
      ball.vy *= -1; playSfx(800, 5); break;
    }
    if (missile.active && missile.x > bx && missile.x < bx + 10 && missile.y > by && missile.y < by + 4) {
      bricks[i].hp -= 5;
      if (bricks[i].hp <= 0) { bricks[i].active = false; nuyen += 25; }
      missile.active = false; playSfx(1600, 20);
    }
  }
  if (clear) { currentLevel++; generateLevel(); playSfx(1200, 100); }
}

void drawUI() {
  u8g2.firstPage(); do {
    if (state == TITLE) {
      u8g2.setFont(u8g2_font_6x12_tf); 
      u8g2.drawStr(12, 40, "BREAKER"); u8g2.drawStr(10, 52, "LINK RPG");
      u8g2.setFont(u8g2_font_4x6_tf); u8g2.drawStr(15, 80, "PUSH DIAL");
      if (digitalRead(BTN_PSH) == LOW) { state = PLAYING; delay(250); }
    } 
    else if (state == PLAYING) {
      u8g2.setFont(u8g2_font_4x6_tf);
      // Row 1: LV
      u8g2.setCursor(2, 6); u8g2.print("LVL:"); u8g2.print(currentLevel);
      // Row 2: NY (Currency gets its own line)
      u8g2.setCursor(2, 14); u8g2.print("NY:"); u8g2.print(nuyen);
      // Row 3: Integrity (Number) & TAC (Blink)
      u8g2.setCursor(2, 22); u8g2.print("INT:"); u8g2.print(integrity);
      u8g2.setCursor(35, 22); u8g2.print("TAC:"); 
      bool blink = (tacCharge >= TAC_MAX && (millis() / 200) % 2 == 0);
      if (!blink) u8g2.drawBox(50, 18, map(tacCharge, 0, TAC_MAX, 0, 12), 4);
      u8g2.drawHLine(0, 28, 64);

      for (int i = 0; i < ROWS * COLS; i++) {
        if (!bricks[i].active) continue;
        int bx = (i % COLS) * 12 + 2; int by = (i / COLS) * 6 + 32;
        if (bricks[i].sentinel) u8g2.drawBox(bx+3, by+1, 4, 2); 
        if (bricks[i].hp > 1) u8g2.drawBox(bx, by, 10, 4); 
        else u8g2.drawFrame(bx, by, 10, 4);
      }
      u8g2.drawHLine(pX, 122, pW);
      if (shieldActive) u8g2.drawFrame(pX-2, 120, pW+4, 4);
      if (ball.active) u8g2.drawDisc(ball.x, ball.y, 2);
      else u8g2.drawStr(pX, 115, "READY");
      if (missile.active) u8g2.drawBox(missile.x-1, missile.y, 2, 4);
      if (pulse.active) u8g2.drawVLine(pulse.x, pulse.y, 4);
    }
    else if (state == SHOP) {
      shopIdx = constrain(shopIdx + (encoderDelta/8), 0, 2); encoderDelta = 0;
      u8g2.setFont(u8g2_font_5x7_tf); u8g2.drawStr(5, 12, "BLACK MARKET");
      u8g2.setFont(u8g2_font_4x6_tf); u8g2.setCursor(5, 22); u8g2.print("NY:"); u8g2.print(nuyen);
      const char* opts[] = {"WIDEN(500)", "POWER(1000)", "FIX(250)"};
      for(int i=0; i<3; i++) {
        u8g2.setCursor(5, 45 + (i*12)); if(i == shopIdx) u8g2.print("> "); else u8g2.print("  "); u8g2.print(opts[i]);
      }
      if (digitalRead(BTN_PSH) == LOW) {
        if (shopIdx == 0 && nuyen >= 500) { pW += 2; nuyen -= 500; playSfx(1000, 50); }
        if (shopIdx == 1 && nuyen >= 1000) { ballPower++; nuyen -= 1000; playSfx(1200, 50); }
        if (shopIdx == 2 && nuyen >= 250) { integrity = min(maxIntegrity, integrity + 15); nuyen -= 250; playSfx(1500, 50); }
        delay(250);
      }
      if (digitalRead(BTN_CON) == LOW) { state = PLAYING; delay(250); }
    }
    else if (state == GAMEOVER) {
      u8g2.setFont(u8g2_font_6x12_tf); u8g2.drawStr(2, 60, "JACKED OUT");
      if (digitalRead(BTN_PSH) == LOW) { currentLevel = 1; nuyen = 0; integrity = 40; state = TITLE; generateLevel(); delay(250); }
    }
  } while (u8g2.nextPage());
}

void loop() { if (state == PLAYING) updateGame(); drawUI(); }