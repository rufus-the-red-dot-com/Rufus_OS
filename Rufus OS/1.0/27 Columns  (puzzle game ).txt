#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

// SH1106 128x64 I2C
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// --- PIN DEFINITIONS ---
#define STICK_X    A0
#define STICK_Y    A1
#define BTN_ROTATE 11 
#define BZ_OUT     3  

// --- GAME CONSTANTS ---
#define COLS 6
#define ROWS 10     
#define BOARD_X 50  
#define BOARD_Y 7   

// --- ENUMS ---
enum GameState { TITLE, PLAYING, CLEARING, GAMEOVER };

// --- GLOBAL STATE ---
GameState state = TITLE;
uint8_t board[COLS][ROWS];
bool matchBoard[COLS][ROWS]; // Tracks which jewels are currently clearing
uint8_t falling[3];     
uint8_t nextJewels[3];  
int8_t pX = 2;          
float pY = 0;           
float fallSpeed = 0.04f;
uint32_t score = 0;
int clearTimer = 0;

// --- HARDWARE-SAFE CLIPPING ---
void safeLine(int x1, int y1, int x2, int y2) {
  x1 = constrain(x1, 0, 127); x2 = constrain(x2, 0, 127);
  y1 = constrain(y1, 0, 63);  y2 = constrain(y2, 0, 63);
  u8g2.drawLine(x1, y1, x2, y2);
}

void safeBox(int x, int y, int w, int h) {
  int x1 = constrain(x, 0, 127);
  int y1 = constrain(y, 0, 63);
  int x2 = constrain(x + w, 0, 127);
  int y2 = constrain(y + h, 0, 63);
  if (x2 <= x1 || y2 <= y1) return;
  u8g2.drawBox(x1, y1, x2 - x1, y2 - y1);
}

void safeFrame(int x, int y, int w, int h) {
  int x1 = constrain(x, 0, 127);
  int y1 = constrain(y, 0, 63);
  int x2 = constrain(x + w, 0, 127);
  int y2 = constrain(y + h, 0, 63);
  if (x2 <= x1 || y2 <= y1) return;
  u8g2.drawFrame(x1, y1, x2 - x1, y2 - y1);
}

void safeDisc(int x, int y, int r) {
  if (x < -r || x > 127+r || y < -r || y > 63+r) return;
  u8g2.drawDisc(constrain(x, 0, 127), constrain(y, 0, 63), r);
}

// --- UTILS ---
void playSfx(int f, int d) { tone(BZ_OUT, f, d); }

void generateTriple(uint8_t t[3]) {
  for(int i=0; i<3; i++) t[i] = random(1, 7); 
}

void initGame() {
  for(int x=0; x<COLS; x++) {
    for(int y=0; y<ROWS; y++) {
        board[x][y] = 0;
        matchBoard[x][y] = false;
    }
  }
  generateTriple(falling);
  generateTriple(nextJewels);
  pX = 2; pY = 0;
  score = 0; fallSpeed = 0.04f;
  state = PLAYING;
  playSfx(880, 100);
}

// --- SOLID JEWEL GRAPHICS ---
void drawJewel(int x, int y, uint8_t type, bool flicker) {
  if (type == 0) return;
  if (flicker && (millis() / 50) % 2 == 0) return; // Flash during clear

  switch(type) {
    case 1: // Solid Square
      safeBox(x+1, y+1, 3, 3);
      break;
    case 2: // Thick Frame
      safeFrame(x, y, 5, 5);
      safeFrame(x+1, y+1, 3, 3);
      break;
    case 3: // Solid Diamond
      safeLine(x+2, y, x, y+2); safeLine(x+2, y, x+4, y+2);
      safeLine(x, y+2, x+2, y+4); safeLine(x+4, y+2, x+2, y+4);
      u8g2.drawPixel(x+2, y+1); u8g2.drawPixel(x+2, y+2); u8g2.drawPixel(x+2, y+3);
      u8g2.drawPixel(x+1, y+2); u8g2.drawPixel(x+3, y+2);
      break;
    case 4: // Solid Circle
      safeDisc(x+2, y+2, 2);
      break;
    case 5: // Triangle Up
      safeLine(x+2, y, x, y+4); safeLine(x+2, y, x+4, y+4); safeLine(x, y+4, x+4, y+4);
      u8g2.drawPixel(x+2, y+1); u8g2.drawPixel(x+2, y+2); u8g2.drawPixel(x+1, y+3); u8g2.drawPixel(x+3, y+3);
      break;
    case 6: // Triangle Down
      safeLine(x, y, x+4, y); safeLine(x, y, x+2, y+4); safeLine(x+4, y, x+2, y+4);
      u8g2.drawPixel(x+2, y+3); u8g2.drawPixel(x+2, y+2); u8g2.drawPixel(x+1, y+1); u8g2.drawPixel(x+3, y+1);
      break;
  }
}

// --- LOGIC ---
bool identifyMatches() {
  bool found = false;
  for(int x=0; x<COLS; x++) for(int y=0; y<ROWS; y++) matchBoard[x][y] = false;

  for(int x=0; x<COLS; x++) {
    for(int y=0; y<ROWS; y++) {
      if (board[x][y] == 0) continue;
      uint8_t type = board[x][y];
      // Vert
      if (y < ROWS-2 && board[x][y+1] == type && board[x][y+2] == type) {
        matchBoard[x][y] = matchBoard[x][y+1] = matchBoard[x][y+2] = true; found = true;
      }
      // Horiz
      if (x < COLS-2 && board[x+1][y] == type && board[x+2][y] == type) {
        matchBoard[x][y] = matchBoard[x+1][y] = matchBoard[x+2][y] = true; found = true;
      }
      // Diag DR
      if (x < COLS-2 && y < ROWS-2 && board[x+1][y+1] == type && board[x+2][y+2] == type) {
        matchBoard[x][y] = matchBoard[x+1][y+1] = matchBoard[x+2][y+2] = true; found = true;
      }
      // Diag DL
      if (x >= 2 && y < ROWS-2 && board[x-1][y+1] == type && board[x-2][y+2] == type) {
        matchBoard[x][y] = matchBoard[x-1][y+1] = matchBoard[x-2][y+2] = true; found = true;
      }
    }
  }
  return found;
}

void finalizeClear() {
  for(int x=0; x<COLS; x++) {
    for(int y=0; y<ROWS; y++) {
      if (matchBoard[x][y]) { board[x][y] = 0; score += 10; }
    }
  }
}

void applyGravity() {
  for(int x=0; x<COLS; x++) {
    for(int y=ROWS-1; y>0; y--) {
      if (board[x][y] == 0) {
        for(int k=y-1; k>=0; k--) {
          if (board[x][k] != 0) { board[x][y] = board[x][k]; board[x][k] = 0; break; }
        }
      }
    }
  }
}

void rotateFalling() {
  uint8_t temp = falling[2];
  falling[2] = falling[1];
  falling[1] = falling[0];
  falling[0] = temp;
  playSfx(600, 20);
}

void lockAndNew() {
  int iy = (int)pY;
  if (iy < 0) iy = 0;
  if (iy > ROWS - 3) iy = ROWS - 3;

  board[pX][iy] = falling[0];
  board[pX][iy+1] = falling[1];
  board[pX][iy+2] = falling[2];

  if (identifyMatches()) {
    state = CLEARING;
    clearTimer = 20; // 20 frames of flickering
    playSfx(1200, 100);
  } else {
    for(int i=0; i<3; i++) falling[i] = nextJewels[i];
    generateTriple(nextJewels);
    pX = 2; pY = 0;
    fallSpeed += 0.001f;
    if (board[pX][0] != 0) state = GAMEOVER;
  }
}

void updateInput() {
  static unsigned long lastMove = 0;
  if (millis() - lastMove < 130) return;
  int sx = analogRead(STICK_X);
  int sy = analogRead(STICK_Y);

  if (sx < 300 && pX > 0) {
    if (board[pX-1][(int)pY+2] == 0) { pX--; lastMove = millis(); playSfx(400, 10); }
  }
  if (sx > 700 && pX < COLS-1) {
    if (board[pX+1][(int)pY+2] == 0) { pX++; lastMove = millis(); playSfx(400, 10); }
  }
  if (sy > 700) pY += 0.45f;

  static bool btnPressed = false;
  if (digitalRead(BTN_ROTATE) == LOW) {
    if (!btnPressed) { rotateFalling(); btnPressed = true; }
  } else btnPressed = false;
}

void drawUI() {
  u8g2.firstPage();
  do {
    if (state == TITLE) {
      u8g2.setFont(u8g2_font_7x14_tf); u8g2.drawStr(35, 30, "COLUMNS");
      u8g2.setFont(u8g2_font_4x6_tf); u8g2.drawStr(30, 50, "PRESS ROTATE TO START");
    } 
    else if (state == GAMEOVER) {
      u8g2.setFont(u8g2_font_7x14_tf); u8g2.drawStr(30, 30, "GAME OVER");
      u8g2.setCursor(40, 45); u8g2.print("SCORE: "); u8g2.print(score);
    }
    else {
      safeFrame(BOARD_X - 1, BOARD_Y - 1, (COLS * 5) + 1, (ROWS * 5) + 1);

      for(int x=0; x<COLS; x++) {
        for(int y=0; y<ROWS; y++) {
          if (board[x][y] != 0) drawJewel(BOARD_X + (x * 5), BOARD_Y + (y * 5), board[x][y], matchBoard[x][y]);
        }
      }

      if (state == PLAYING) {
        for(int i=0; i<3; i++) {
          int ry = (int)pY + i;
          if (ry < ROWS) drawJewel(BOARD_X + (pX * 5), BOARD_Y + (ry * 5), falling[i], false);
        }
      }

      u8g2.setFont(u8g2_font_4x6_tf);
      u8g2.drawStr(5, 10, "NEXT");
      for(int i=0; i<3; i++) drawJewel(10, 15 + (i * 6), nextJewels[i], false);
      u8g2.setCursor(90, 10); u8g2.print("SCORE");
      u8g2.setCursor(90, 20); u8g2.print(score);
    }
  } while (u8g2.nextPage());
}

void setup() {
  pinMode(BTN_ROTATE, INPUT_PULLUP);
  u8g2.begin();
  randomSeed(analogRead(A2));
}

void loop() {
  if (state == TITLE) {
    if (digitalRead(BTN_ROTATE) == LOW) initGame();
  } 
  else if (state == PLAYING) {
    updateInput();
    pY += fallSpeed;
    int iy = (int)pY;
    if (iy + 3 >= ROWS || board[pX][iy+3] != 0) lockAndNew();
  }
  else if (state == CLEARING) {
    clearTimer--;
    if (clearTimer <= 0) {
      finalizeClear();
      applyGravity();
      if (identifyMatches()) {
        clearTimer = 15; // Chain reaction clear
        playSfx(1500, 50);
      } else {
        // Prepare next piece
        for(int i=0; i<3; i++) falling[i] = nextJewels[i];
        generateTriple(nextJewels);
        pX = 2; pY = 0;
        state = PLAYING;
        if (board[pX][0] != 0) state = GAMEOVER;
      }
    }
  }
  else if (state == GAMEOVER) {
    if (digitalRead(BTN_ROTATE) == LOW) state = TITLE;
  }
  drawUI();
}