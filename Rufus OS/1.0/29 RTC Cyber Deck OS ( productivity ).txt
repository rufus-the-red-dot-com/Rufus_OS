#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>
#include "RTClib.h"

// --- 1. HARDWARE ---
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
RTC_DS3231 rtc;

#define STICK_X    A0  
#define STICK_Y    A1  
#define STICK_SW   2   
#define BZ_OUT     3   
#define BZ_OUT2    6   
#define BAT_PIN    A3  

// --- 2. OS STATE ---
enum AppState { CLOCK_FACE, MENU, CALCULATOR, CALENDAR, TIMER, ALARM, STOPWATCH, METRONOME, SET_TIME };
AppState currentState = CLOCK_FACE;

int menuIdx = 0;
unsigned long lastInput = 0, swTimer = 0;
bool swPressed = false;
int lastChimeHour = -1;
const char* monthNames[] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
const char* dayNames[] = {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};

// App Vars
int cal_view_m, cal_view_y;
int alarm_h = 7, alarm_m = 0;
bool alarm_is_pm = false, alarm_active = false, alarm_ringing = false;
unsigned long scrollSpeed = 250; 
int set_time_idx = 0; 
float calc_val1 = 0; char calc_op = ' '; int calc_cursor = 0; String calc_input = "";
const char calc_keys[16] = {'7','8','9','/','4','5','6','*','1','2','3','-','C','0','=','+'};
unsigned long timer_start = 0, timer_duration = 1500; bool timer_running = false;
unsigned long sw_start = 0, sw_elapsed = 0; bool sw_running = false;
int metro_bpm = 120; unsigned long metro_last_tick = 0;

// --- 3. UTILITIES ---

void playSfx(int f, int d) { 
  if (f <= 0) return;
  long delayTime = 1000000L / f / 2;
  for (long i = 0; i < (long)f * d / 1000L; i++) {
    digitalWrite(BZ_OUT, HIGH); digitalWrite(BZ_OUT2, HIGH);
    delayMicroseconds(delayTime);
    digitalWrite(BZ_OUT, LOW); digitalWrite(BZ_OUT2, LOW);
    delayMicroseconds(delayTime);
  }
}

float getBatteryVoltage() {
  int raw = analogRead(BAT_PIN);
  if (raw < 50) return 0.0;
  float vPin = (raw * 5.0) / 1024.0;
  // Calibration: adjust 3.12 if the reading doesn't match a multimeter
  return vPin * 3.12; 
}

int getStartDay(int y, int m) {
  if (m < 3) { m += 12; y--; }
  int k = y % 100, j = y / 100;
  int h = (1 + (13 * (m + 1)) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;
  return (h + 5) % 7; 
}

int daysInMonth(int y, int m) {
  if (m == 2) return ((y % 4 == 0 && y % 100 != 0) || (y % 400 == 0)) ? 29 : 28;
  if (m == 4 || m == 6 || m == 9 || m == 11) return 30;
  return 31;
}

// --- 4. DRAWING ---

void drawClockFace() {
  DateTime now = rtc.now();
  int h12 = now.hour(); bool pm = h12 >= 12;
  if(h12==0) h12=12; else if(h12>12) h12-=12;

  u8g2.setFont(u8g2_font_logisoso32_tn);
  u8g2.setCursor(5, 42); u8g2.print(h12); u8g2.print(":"); 
  if(now.minute() < 10) u8g2.print("0"); u8g2.print(now.minute());

  u8g2.setFont(u8g2_font_7x14_tf); u8g2.setCursor(105, 42); 
  if(now.second() < 10) u8g2.print("0"); u8g2.print(now.second());
  u8g2.setFont(u8g2_font_5x7_tf); u8g2.setCursor(105, 18); u8g2.print(pm ? "PM" : "AM");
  
  // Improved Battery Meter
  float batV = getBatteryVoltage();
  u8g2.drawFrame(110, 2, 12, 6); u8g2.drawBox(122, 4, 2, 2); 
  // Map 6.8V (Empty) to 9.0V (Full)
  int batPercent = map(constrain(batV * 10, 68, 90), 68, 90, 0, 10);
  if (batV > 1.0) u8g2.drawBox(111, 3, batPercent, 4);
  else u8g2.drawStr(112, 8, "?");

  u8g2.drawHLine(0, 48, 128); 
  u8g2.setCursor(5, 60);
  u8g2.print(dayNames[now.dayOfTheWeek()]); u8g2.print(" ");
  u8g2.print(now.day()); u8g2.print(" "); u8g2.print(monthNames[now.month()-1]);
  u8g2.drawStr(70, 60, "CASIO"); 
  u8g2.setCursor(105, 60); u8g2.print((int)rtc.getTemperature()); u8g2.print("C");
  if(alarm_active) u8g2.drawDisc(120, 10, 3);
}

// Apps (Restored)
void drawMenu() { const char* apps[]={"CALC","CALENDAR","TIMER","ALARM","WATCH","METRO","SET CLOCK"}; u8g2.setFont(u8g2_font_5x7_tf); for(int i=0;i<7;i++){ if(menuIdx==i){u8g2.drawBox(0,(i*9),128,9); u8g2.setDrawColor(0); u8g2.drawStr(10,7+(i*9),apps[i]); u8g2.setDrawColor(1);} else {u8g2.drawStr(10,7+(i*9),apps[i]);}}}
void drawCalculator() { u8g2.setFont(u8g2_font_5x7_tf); u8g2.setCursor(10, 12); u8g2.print(calc_input == "" ? "0" : calc_input); for(int i=0; i<16; i++){ int x=(i%4)*25+15, y=(i/4)*10+25; if(calc_cursor==i) u8g2.drawFrame(x-2,y-7,18,9); u8g2.setCursor(x,y); u8g2.print(calc_keys[i]); } }
void drawCalendar() { DateTime now = rtc.now(); u8g2.setFont(u8g2_font_5x7_tf); u8g2.setCursor(5, 10); u8g2.print(monthNames[cal_view_m-1]); u8g2.print(" "); u8g2.print(cal_view_y); int s = getStartDay(cal_view_y, cal_view_m); int d = daysInMonth(cal_view_y, cal_view_m); for(int i=1; i<=d; i++) { int p = s + i - 1; int x = (p % 7) * 17 + 5, y = (p / 7) * 8 + 25; if(i == now.day() && cal_view_m == now.month() && cal_view_y == now.year()) u8g2.drawFrame(x-2, y-7, 14, 9); u8g2.setCursor(x, y); u8g2.print(i); } }
void drawAlarm() { u8g2.setFont(u8g2_font_10x20_tf); u8g2.setCursor(20, 35); if(alarm_h < 10) u8g2.print("0"); u8g2.print(alarm_h); u8g2.print(":"); if(alarm_m < 10) u8g2.print("0"); u8g2.print(alarm_m); u8g2.print(alarm_is_pm ? " PM" : " AM"); if (swPressed && (millis() - swTimer > 500)) u8g2.drawBox(5, 45, map(constrain(millis() - swTimer, 0, 5000), 0, 5000, 0, 118), 4); u8g2.setFont(u8g2_font_5x7_tf); u8g2.setCursor(20, 60); u8g2.print(alarm_active ? "ALARM: ACTIVE" : "ALARM: OFF (HOLD 5S)"); }
void drawTimer() { u8g2.setFont(u8g2_font_10x20_tf); long r = timer_running ? (long)timer_duration - (long)((millis()-timer_start)/1000) : timer_duration; if(r < 0) r = 0; u8g2.setCursor(35, 40); u8g2.print(r/60); u8g2.print(":"); if(r%60 < 10) u8g2.print("0"); u8g2.print(r%60); }
void drawStopwatch() { u8g2.setFont(u8g2_font_10x20_tf); unsigned long c = sw_running ? (sw_elapsed + (millis() - sw_start)) : sw_elapsed; u8g2.setCursor(20, 40); u8g2.print(c/1000); u8g2.print("."); u8g2.print((c%1000)/10); }
void drawMetronome() { u8g2.setFont(u8g2_font_10x20_tf); u8g2.setCursor(45, 40); u8g2.print(metro_bpm); u8g2.setFont(u8g2_font_5x7_tf); u8g2.drawStr(45, 55, "BPM"); if((millis() % (60000 / metro_bpm)) < 100) u8g2.drawDisc(64, 20, 6); else u8g2.drawCircle(64, 20, 6); }
void drawSetTime() { DateTime n = rtc.now(); u8g2.setFont(u8g2_font_5x7_tf); u8g2.drawStr(10, 15, "SYNC UTILITY"); u8g2.setCursor(10, 40); if(set_time_idx==0) u8g2.print(">H:"); else u8g2.print("H:"); u8g2.print(n.hour()); u8g2.setCursor(45, 40); if(set_time_idx==1) u8g2.print(">M:"); else u8g2.print("M:"); u8g2.print(n.minute()); u8g2.setCursor(80, 40); if(set_time_idx==2) u8g2.print(">S:"); else u8g2.print("S:"); if(n.second()<10)u8g2.print("0"); u8g2.print(n.second()); u8g2.setCursor(10, 55); if(set_time_idx==3) u8g2.print(">D:"); else u8g2.print("D:"); u8g2.print(n.day()); }

// --- 5. LOGIC ---

void handleInput() {
  int sy = analogRead(STICK_X), sx = analogRead(STICK_Y);
  bool swState = (digitalRead(STICK_SW) == LOW);
  unsigned long now = millis();
  bool click = false, holdLong = false, holdFive = false;
  if (swState && !swPressed) { swTimer = now; swPressed = true; }
  else if (!swState && swPressed) {
    unsigned long dur = now - swTimer;
    if (dur > 5000) holdFive = true; else if (dur > 600) holdLong = true; else if (dur > 50) click = true;
    swPressed = false;
  }
  if (holdLong && !holdFive) { currentState = CLOCK_FACE; playSfx(400, 50); return; }
  if (holdFive && currentState == ALARM) { alarm_active = !alarm_active; playSfx(1200, 200); return; }
  if (now - lastInput < 200 && currentState != ALARM) return;

  switch(currentState) {
    case CLOCK_FACE: if(click) currentState = MENU; break;
    case MENU: if(sy > 800) menuIdx = max(0, menuIdx-1); else if(sy < 200) menuIdx = min(6, menuIdx+1); if(click) { currentState = (AppState)(menuIdx + 2); if(currentState == CALENDAR) { DateTime n=rtc.now(); cal_view_m=n.month(); cal_view_y=n.year(); } } lastInput = now; break;
    case ALARM: if (sy > 800 || sy < 200) { if (now - lastInput > scrollSpeed) { if (sy > 800) { alarm_m--; if(alarm_m < 0) { alarm_m = 59; alarm_h--; if(alarm_h < 1) alarm_h = 12; }} else { alarm_m++; if(alarm_m > 59) { alarm_m = 0; alarm_h++; if(alarm_h > 12) alarm_h = 1; }} scrollSpeed = max(30, scrollSpeed - 30); lastInput = now; } } else { scrollSpeed = 250; } if(click) alarm_is_pm = !alarm_is_pm; break;
    case CALCULATOR: if(sx < 200) calc_cursor = (calc_cursor%4==0)?calc_cursor:calc_cursor-1; else if(sx > 800) calc_cursor = (calc_cursor%4==3)?calc_cursor:calc_cursor+1; if(sy > 800) calc_cursor = (calc_cursor<4)?calc_cursor:calc_cursor-4; else if(sy < 200) calc_cursor = (calc_cursor>11)?calc_cursor:calc_cursor+4; if(click){ char k=calc_keys[calc_cursor]; if(k>='0'&&k<='9') calc_input+=k; else if(k=='C'){calc_input="";calc_val1=0;} else if(k=='='){ float v2=calc_input.toFloat(); if(calc_op=='+')calc_val1+=v2; else if(calc_op=='-')calc_val1-=v2; else if(calc_op=='*')calc_val1*=v2; else if(calc_op=='/')if(v2!=0)calc_val1/=v2; calc_input=String(calc_val1); calc_op=' ';} else {calc_val1=calc_input.toFloat(); calc_op=k; calc_input="";} lastInput=now; playSfx(800,15); } break;
    case CALENDAR: if(sy > 800){ cal_view_m--; if(cal_view_m<1){cal_view_m=12; cal_view_y--;} } else if(sy < 200){ cal_view_m++; if(cal_view_m>12){cal_view_m=1; cal_view_y++;} } lastInput = now; break;
    case TIMER: if(click){timer_running=!timer_running; timer_start=now;} if(sy>800)timer_duration+=60; lastInput=now; break;
    case STOPWATCH: if(click){if(!sw_running){sw_start=now; sw_running=true;} else{sw_elapsed+=(now-sw_start); sw_running=false;}} if(sy<200){sw_elapsed=0; sw_running=false;} lastInput=now; break;
    case METRONOME: if(sy > 800) metro_bpm++; else if(sy < 200) metro_bpm--; lastInput=now; break;
    case SET_TIME: if(click) {set_time_idx=(set_time_idx+1)%4; playSfx(1000,10);} if(sy>800||sy<200){DateTime n=rtc.now(); int h=n.hour(), m=n.minute(), s=n.second(), d=n.day(); if(set_time_idx == 0) h = (sy > 800) ? (h+1)%24 : (h+23)%24; if(set_time_idx == 1) { m = (sy > 800) ? (m+1)%60 : (m+59)%60; s = 0; } if(set_time_idx == 2) s = (sy > 800) ? (s+1)%60 : (s+59)%60; if(set_time_idx == 3) d = (sy > 800) ? (d+1)%31 : (d+30)%31; rtc.adjust(DateTime(n.year(), n.month(), d, h, m, s)); lastInput=now;} break;
  }
}

void setup() {
  pinMode(STICK_SW, INPUT_PULLUP); pinMode(BZ_OUT, OUTPUT); pinMode(BZ_OUT2, OUTPUT);
  Wire.begin(); u8g2.begin(); rtc.begin();
  if (rtc.lostPower()) { rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); playSfx(2000, 500); }
}

void loop() {
  handleInput();
  DateTime now = rtc.now();
  if (currentState == METRONOME && (millis() - metro_last_tick > (60000 / metro_bpm))) { playSfx(2000, 5); metro_last_tick = millis(); }
  if (now.minute() == 0 && now.second() == 0 && now.hour() != lastChimeHour) { playSfx(1800, 100); delay(50); playSfx(1800, 100); lastChimeHour = now.hour(); }
  int checkH = alarm_h; if(!alarm_is_pm && checkH == 12) checkH = 0; else if(alarm_is_pm && checkH != 12) checkH += 12;
  if(alarm_active && now.hour() == checkH && now.minute() == alarm_m) alarm_ringing = true;
  if(alarm_ringing) { playSfx(2000, 100); if(digitalRead(STICK_SW)==LOW) { alarm_ringing = false; alarm_active = false; } }
  u8g2.firstPage();
  do {
    if(alarm_ringing) { u8g2.setFont(u8g2_font_10x20_tf); u8g2.drawStr(30, 40, "ALARM!"); }
    else { switch(currentState) {
      case CLOCK_FACE: drawClockFace(); break; case MENU: drawMenu(); break; case CALCULATOR: drawCalculator(); break;
      case CALENDAR: drawCalendar(); break; case TIMER: drawTimer(); break; case ALARM: drawAlarm(); break;
      case STOPWATCH: drawStopwatch(); break; case METRONOME: drawMetronome(); break; case SET_TIME: drawSetTime(); break;
    }}
  } while (u8g2.nextPage());
}