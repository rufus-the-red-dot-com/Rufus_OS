#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

// SH1106 128x64 I2C
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// --- PIN DEFINITIONS ---
#define STICK_X    A0
#define STICK_Y    A1
#define BTN_ACTION 11 // Select / Drag-Swap
#define BTN_INVERT 9  // Toggle Light/Dark Mode
#define BTN_STATS  10 // Open Cyberdeck (Stats)
#define BZ_SFX     3  
#define BZ_SFX_2   6  

// --- GAME CONSTANTS ---
#define GRID_SIZE 6
#define CELL_SIZE 10
#define GRID_X    48
#define GRID_Y    2
#define TYPE_COUNT 5

// --- ENUMS ---
enum GameState { TITLE, PLAYING, MATCHING, DROPPING, MILESTONE, COMMUNICATION, CYBERDECK };
enum PieceType { EMPTY, CHIP, VOLT, VIRUS, NODE, CORE };

struct Piece {
  uint8_t type;
  bool isMatching;
  float yOffset; 
};

// --- CYBERPUNK FLAVOR DATA ---
const char* CORPORATIONS[] = {"ARASAKA", "MILITECH", "KANG TAO", "ZETATECH", "BIOTECHNICA", "NIGHT CORP", "MAELSTROM"};
const char* RUNNERS[] = {"DEX", "T-BUG", "JACKIE", "KIWI", "LUCY", "ROGUE", "ALT", "MAINE"};
const char* MESSAGES[] = {
  "ICE IS THAWING.",
  "WATCH THE TRACE.",
  "JACK OUT SOON.",
  "DUMP THE DATA.",
  "NETWATCH SPOTTED.",
  "KEEP SPLICING.",
  "BLACKWALL IS BREACHED.",
  "NEURAL LINK STABLE.",
  "SIPHON THE CREDITS.",
  "CORPORATE LIES DELETED.",
  "THE MATRIX LIVES.",
  "FOLLOW THE RABBIT."
};

// --- GLOBAL STATE ---
GameState state = TITLE;
Piece grid[GRID_SIZE][GRID_SIZE];
int cursorX = 0, cursorY = 0;
int selectedX = -1, selectedY = -1;

// RPG & Stats
long score = 0;
long highScore = 0;
long totalNuyen = 0;
int level = 1;
int experience = 0;
int corpsHackedCount = 0;
int xpToNextLevel = 500;

long nextMilestone = 500;
bool isInverted = false;
unsigned long stateTimer = 0;

// Hacking HUD state
const char* currentTarget = "NONE";
const char* runnerName = "SYSTEM";
const char* runnerMsg = "INITIALIZING...";
int nuyenEarned = 0;
unsigned long msgTimer = 0;

// --- AUDIO: AGGRESSIVE CYBERPUNK SYNTH ---
void playCyberMusic() {
  int notes[] = {110, 110, 146, 110, 164, 110, 130, 110};
  for(int i=0; i<8; i++) {
    tone(BZ_SFX, notes[i], 80);
    if(i % 2 == 0) tone(BZ_SFX_2, notes[i] * 1.5, 40);
    delay(130);
  }
  noTone(BZ_SFX);
  noTone(BZ_SFX_2);
}

void playMatchSound(int combo) {
  for(int i=0; i<3; i++) {
    tone(BZ_SFX, 800 + (combo * 200) + (i * 100), 20);
    delay(30);
  }
}

void playHackingSuccess() {
  tone(BZ_SFX, 400, 100); delay(100);
  tone(BZ_SFX, 800, 100); delay(100);
  tone(BZ_SFX, 1600, 200);
}

// --- PIECE GRAPHICS ---
void drawPiece(int x, int y, uint8_t type, float offset) {
  int px = GRID_X + (x * CELL_SIZE) + 1;
  int py = GRID_Y + (y * CELL_SIZE) + 1 + (int)offset;
  
  switch(type) {
    case CHIP: 
      u8g2.drawFrame(px+2, py+2, 5, 5); 
      u8g2.drawPixel(px+4, py+4); 
      break;
    case VOLT: 
      u8g2.drawLine(px+2, py+2, px+7, py+7); 
      u8g2.drawLine(px+7, py+2, px+2, py+7); 
      break;
    case VIRUS: 
      u8g2.drawCircle(px+4, py+4, 3); 
      u8g2.drawPixel(px+4, py+4); 
      break;
    case NODE: 
      u8g2.drawBox(px+2, py+2, 5, 5); 
      break;
    case CORE: 
      u8g2.drawDisc(px+4, py+4, 3); 
      break;
  }
}

bool checkMatches();

void initGrid() {
  bool initialMatches = true;
  while(initialMatches) {
    for(int x=0; x<GRID_SIZE; x++) {
      for(int y=0; y<GRID_SIZE; y++) {
        grid[x][y].type = random(1, TYPE_COUNT + 1);
        grid[x][y].isMatching = false;
        grid[x][y].yOffset = 0;
      }
    }
    initialMatches = checkMatches();
  }
  for(int x=0; x<GRID_SIZE; x++) {
    for(int y=0; y<GRID_SIZE; y++) grid[x][y].isMatching = false;
  }
}

bool checkMatches() {
  bool found = false;
  for(int x=0; x<GRID_SIZE; x++) {
    for(int y=0; y<GRID_SIZE; y++) grid[x][y].isMatching = false;
  }

  for(int y=0; y<GRID_SIZE; y++) {
    for(int x=0; x<GRID_SIZE-2; x++) {
      uint8_t t = grid[x][y].type;
      if(t != EMPTY && grid[x+1][y].type == t && grid[x+2][y].type == t) {
        grid[x][y].isMatching = grid[x+1][y].isMatching = grid[x+2][y].isMatching = true;
        found = true;
      }
    }
  }
  for(int x=0; x<GRID_SIZE; x++) {
    for(int y=0; y<GRID_SIZE-2; y++) {
      uint8_t t = grid[x][y].type;
      if(t != EMPTY && grid[x][y+1].type == t && grid[x][y+2].type == t) {
        grid[x][y].isMatching = grid[x][y+1].isMatching = grid[x][y+2].isMatching = true;
        found = true;
      }
    }
  }
  return found;
}

void applyMatches() {
  int count = 0;
  for(int x=0; x<GRID_SIZE; x++) {
    for(int y=0; y<GRID_SIZE; y++) {
      if(grid[x][y].isMatching) {
        grid[x][y].type = EMPTY;
        grid[x][y].isMatching = false;
        count++;
      }
    }
  }
  
  int points = count * 15;
  score += points;
  experience += points;

  if (score > highScore) highScore = score;

  // Level Up Check
  if (experience >= xpToNextLevel) {
    level++;
    experience = 0;
    xpToNextLevel += 500;
    tone(BZ_SFX, 1000, 100); delay(110);
    tone(BZ_SFX, 2000, 200);
  }

  // Milestone / Hacking Goal Check
  if (score >= nextMilestone) {
    currentTarget = CORPORATIONS[random(0, 7)];
    nuyenEarned = random(500, 5000);
    totalNuyen += nuyenEarned;
    corpsHackedCount++;
    nextMilestone += 1000;
    state = MILESTONE;
    stateTimer = millis();
    playHackingSuccess();
  }

  if(count > 0) playMatchSound(count/3);
}

void applyGravity() {
  for(int x=0; x<GRID_SIZE; x++) {
    for(int y=GRID_SIZE-1; y>=0; y--) {
      if(grid[x][y].type == EMPTY) {
        for(int k=y-1; k>=0; k--) {
          if(grid[x][k].type != EMPTY) {
            grid[x][y].type = grid[x][k].type;
            grid[x][k].type = EMPTY;
            break;
          }
        }
      }
    }
    for(int y=0; y<GRID_SIZE; y++) {
      if(grid[x][y].type == EMPTY) {
        grid[x][y].type = random(1, TYPE_COUNT + 1);
      }
    }
  }
}

void drawGame() {
  u8g2.firstPage();
  do {
    u8g2.setDrawColor(1);
    if(isInverted) u8g2.drawBox(0,0,128,64);
    u8g2.setDrawColor(isInverted ? 0 : 1);

    if (state == TITLE) {
      u8g2.setFont(u8g2_font_7x14_tf);
      u8g2.drawStr(25, 20, "GRID SPLICER");
      u8g2.setFont(u8g2_font_4x6_tf);
      u8g2.setCursor(25, 32); u8g2.print("SESS-HI: "); u8g2.print(highScore);
      u8g2.setFont(u8g2_font_6x10_tf);
      u8g2.drawStr(22, 48, "MATRIX BREACH");
      if ((millis() / 500) % 2 == 0) u8g2.drawStr(18, 62, "PRESS ACTION (11)");
    } 
    else if (state == MILESTONE) {
      u8g2.setFont(u8g2_font_6x12_tf);
      u8g2.drawStr(10, 20, "HACK SUCCESS!");
      u8g2.setFont(u8g2_font_5x7_tf);
      u8g2.setCursor(10, 35); u8g2.print("TARGET: "); u8g2.print(currentTarget);
      u8g2.setCursor(10, 48); u8g2.print("NUYEN: +"); u8g2.print(nuyenEarned);
      u8g2.drawFrame(5, 5, 118, 54);
      u8g2.setFont(u8g2_font_4x6_tf);
      u8g2.drawStr(35, 60, "CONTINUE [BTN 11]");
    }
    else if (state == COMMUNICATION) {
      u8g2.drawFrame(0, 0, 128, 64);
      u8g2.setFont(u8g2_font_6x12_tf);
      u8g2.drawStr(10, 18, "[!] INCOMING FEED");
      u8g2.drawHLine(5, 22, 118);
      u8g2.setFont(u8g2_font_5x7_tf);
      u8g2.setCursor(10, 36); u8g2.print("RUNNER: "); u8g2.print(runnerName);
      u8g2.setCursor(10, 50); u8g2.print("MSG: "); u8g2.print(runnerMsg);
      u8g2.setFont(u8g2_font_4x6_tf);
      if ((millis() / 400) % 2 == 0) u8g2.drawStr(25, 60, "JACK OUT [PRESS 11]");
    }
    else if (state == CYBERDECK) {
      // Full screen Stat Device
      u8g2.drawFrame(0, 0, 128, 64);
      u8g2.drawBox(0,0, 128, 10);
      u8g2.setDrawColor(isInverted ? 1 : 0);
      u8g2.setFont(u8g2_font_5x7_tf);
      u8g2.drawStr(5, 8, "CYBERDECK v4.2 // RUNNER OS");
      u8g2.setDrawColor(isInverted ? 0 : 1);
      
      u8g2.setCursor(5, 24); u8g2.print("LVL: "); u8g2.print(level);
      u8g2.setCursor(5, 34); u8g2.print("NUYEN: "); u8g2.print(totalNuyen);
      u8g2.setCursor(5, 44); u8g2.print("CORPS BREACHED: "); u8g2.print(corpsHackedCount);
      u8g2.setCursor(5, 54); u8g2.print("XP: "); u8g2.print(experience); u8g2.print("/"); u8g2.print(xpToNextLevel);
      
      u8g2.drawHLine(0, 56, 128);
      u8g2.setFont(u8g2_font_4x6_tf);
      u8g2.drawStr(80, 62, "STATS [BTN 10]");
    }
    else {
      // Defrag Grid
      u8g2.drawFrame(GRID_X-1, GRID_Y-1, (GRID_SIZE*CELL_SIZE)+2, (GRID_SIZE*CELL_SIZE)+2);
      for(int x=0; x<GRID_SIZE; x++) {
        for(int y=0; y<GRID_SIZE; y++) {
          if(grid[x][y].type != EMPTY) drawPiece(x, y, grid[x][y].type, grid[x][y].yOffset);
        }
      }

      // Cursor & Drag
      int cx = GRID_X + (cursorX * CELL_SIZE);
      int cy = GRID_Y + (cursorY * CELL_SIZE);
      u8g2.drawFrame(cx, cy, CELL_SIZE, CELL_SIZE); 
      if (selectedX != -1) {
        int sx = GRID_X + (selectedX * CELL_SIZE);
        int sy = GRID_Y + (selectedY * CELL_SIZE);
        u8g2.drawFrame(sx+2, sy+2, CELL_SIZE-4, CELL_SIZE-4); 
        if ((millis() / 150) % 2 == 0) u8g2.drawLine(sx + 5, sy + 5, cx + 5, cy + 5);
      }

      // Hacking HUD
      u8g2.setFont(u8g2_font_4x6_tf);
      u8g2.setCursor(2, 6); u8g2.print("LVL "); u8g2.print(level);
      u8g2.setCursor(2, 14); u8g2.print("SCR "); u8g2.print(score);
      u8g2.drawHLine(0, 18, 44);
      
      // XP BAR
      u8g2.drawFrame(2, 22, 40, 4);
      int xpW = map(experience, 0, xpToNextLevel, 0, 38);
      u8g2.drawBox(3, 23, xpW, 2);
      
      // Shadowrunner Comm Box
      u8g2.setCursor(2, 36); u8g2.print("[IDLE]");
      u8g2.setCursor(2, 44); u8g2.print("FEEDING...");
      
      u8g2.drawFrame(0, 48, 44, 16);
      u8g2.setCursor(4, 56); u8g2.print("NEXT BRCH");
      u8g2.setCursor(4, 62); u8g2.print(nextMilestone);
    }
  } while (u8g2.nextPage());
}

void updateComm() {
  if (millis() - msgTimer > 15000) {
    if (random(0, 100) < 30) { 
      runnerName = RUNNERS[random(0, 8)];
      runnerMsg = MESSAGES[random(0, 12)];
      state = COMMUNICATION;
      tone(BZ_SFX, 1500, 50);
      delay(80);
      tone(BZ_SFX, 1000, 50);
    }
    msgTimer = millis();
  }
}

void handleInput() {
  static unsigned long lastMove = 0;
  static bool dragStarted = false;

  // Toggle mode with Pin 9
  if (digitalRead(BTN_INVERT) == LOW && millis() - lastMove > 300) {
    isInverted = !isInverted;
    lastMove = millis();
    tone(BZ_SFX, 1200, 10);
  }

  // Open Stats Device with Pin 10
  if (digitalRead(BTN_STATS) == LOW && millis() - lastMove > 300) {
    if (state == PLAYING) state = CYBERDECK;
    else if (state == CYBERDECK) state = PLAYING;
    lastMove = millis();
    tone(BZ_SFX, 800, 30);
  }

  if (state == TITLE) {
    if (digitalRead(BTN_ACTION) == LOW) {
      playCyberMusic();
      score = 0; experience = 0;
      initGrid();
      state = PLAYING;
      msgTimer = millis();
      delay(250);
    }
    return;
  }

  if (state == MILESTONE || state == COMMUNICATION) {
    if (digitalRead(BTN_ACTION) == LOW) {
      state = PLAYING;
      delay(250);
    }
    return;
  }

  if (state == PLAYING) {
    updateComm();
    int stickX = analogRead(STICK_X);
    int stickY = analogRead(STICK_Y);
    int oldCursorX = cursorX;
    int oldCursorY = cursorY;

    if (millis() - lastMove > 180) {
      if (stickX < 300 && cursorX > 0) { cursorX--; lastMove = millis(); }
      if (stickX > 700 && cursorX < GRID_SIZE-1) { cursorX++; lastMove = millis(); }
      if (stickY < 300 && cursorY > 0) { cursorY--; lastMove = millis(); }
      if (stickY > 700 && cursorY < GRID_SIZE-1) { cursorY++; lastMove = millis(); }
    }

    if (digitalRead(BTN_ACTION) == LOW) {
      if (!dragStarted) {
        selectedX = cursorX;
        selectedY = cursorY;
        dragStarted = true;
        tone(BZ_SFX, 900, 20);
      } else if (oldCursorX != cursorX || oldCursorY != cursorY) {
        int dx = abs(selectedX - cursorX);
        int dy = abs(selectedY - cursorY);
        
        if ((dx == 1 && dy == 0) || (dx == 0 && dy == 1)) {
          uint8_t temp = grid[cursorX][cursorY].type;
          grid[cursorX][cursorY].type = grid[selectedX][selectedY].type;
          grid[selectedX][selectedY].type = temp;
          
          if (!checkMatches()) {
            tone(BZ_SFX, 200, 50);
            grid[selectedX][selectedY].type = grid[cursorX][cursorY].type;
            grid[cursorX][cursorY].type = temp;
            selectedX = cursorX;
            selectedY = cursorY;
          } else {
            state = MATCHING;
            stateTimer = millis();
            selectedX = -1; selectedY = -1;
            dragStarted = false;
          }
        }
      }
    } else {
      selectedX = -1;
      selectedY = -1;
      dragStarted = false;
    }
  }
}

void setup() {
  pinMode(BTN_ACTION, INPUT_PULLUP);
  pinMode(BTN_INVERT, INPUT_PULLUP);
  pinMode(BTN_STATS,  INPUT_PULLUP);
  u8g2.begin();
  randomSeed(analogRead(A2));
}

void loop() {
  handleInput();
  
  if (state == MATCHING) {
    if (millis() - stateTimer > 200) {
      if (checkMatches()) {
        applyMatches();
        state = DROPPING;
      } else {
        state = PLAYING;
      }
      stateTimer = millis();
    }
  } 
  else if (state == DROPPING) {
    if (millis() - stateTimer > 200) {
      applyGravity();
      state = MATCHING;
      stateTimer = millis();
    }
  }

  drawGame();
}