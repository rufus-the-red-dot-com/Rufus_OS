#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

// SH1106 128x64 I2C
U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// --- PIN DEFINITIONS ---
#define STICK_X    A0
#define STICK_Y    A1
#define BTN_K1     11 // Key 1
#define BTN_K2     9  // Key 2
#define BTN_K3     10 // Key 3
#define BTN_K4     5  // Key 4 (D5)
#define BZ_OUT     3  // Primary Synth Out

// --- CALIBRATION ---
#define JOYSTICK_DEADZONE 150 // Ignore small movements near center (512)

// --- NOTE FREQUENCIES ---
#define NOTE_G2  98
#define NOTE_A2  110
#define NOTE_B2  123
#define NOTE_C3  131
#define NOTE_D3  147
#define NOTE_E3  165
#define NOTE_F3  175
#define NOTE_G3  196
#define NOTE_A3  220
#define NOTE_B3  247
#define NOTE_C4  262
#define NOTE_CS4 277
#define NOTE_D4  294
#define NOTE_DS4 311
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define NOTE_A5  880
#define NOTE_B5  988
#define NOTE_C6  1047

// --- GLOBAL STATE ---
bool isInverted = false;
int currentFreq = 0;
const char* currentNoteName = "---";
int activeKeySet = 0; // 0: None, 1: K1, 2: K2, 3: K3, 4: K4

// Structure to hold note mappings for the UI (Extended for diagonals)
struct NoteMap {
  const char* up;    int upF;
  const char* down;  int downF;
  const char* left;  int leftF;
  const char* right; int rightF;
  const char* ur;    int urF; // Up-Right
  const char* dr;    int drF; // Down-Right
  const char* ul;    int ulF; // Up-Left
  const char* dl;    int dlF; // Down-Left
};

// Define the 5 registers with 8 notes each
const NoteMap registers[] = {
  // Register 0: Natural Low (No buttons)
  {"C4", NOTE_C4, "D4", NOTE_D4, "E4", NOTE_E4, "F4", NOTE_F4, 
   "G4", NOTE_G4, "A4", NOTE_A4, "B4", NOTE_B4, "C5", NOTE_C5},
   
  // Register 1: Natural Mid (BTN_K1 - Pin 11)
  {"D5", NOTE_D5, "E5", NOTE_E5, "F5", NOTE_F5, "G5", NOTE_G5,
   "A5", NOTE_A5, "B3", NOTE_B3, "A3", NOTE_A3, "G3", NOTE_G3},
   
  // Register 2: Sharps/Flats (BTN_K2 - Pin 9)
  {"C#4", NOTE_CS4, "D#4", NOTE_DS4, "F#4", NOTE_FS4, "G#4", NOTE_GS4,
   "A#4", NOTE_AS4, "C#5", NOTE_CS5, "D#5", NOTE_DS5, "F#5", NOTE_FS5},
   
  // Register 3: Chromatic High (BTN_K3 - Pin 10)
  {"G#3", NOTE_GS4, "C#4", NOTE_CS4, "F#4", NOTE_FS4, "C#5", NOTE_CS5,
   "E4", NOTE_E4, "A4", NOTE_A4, "D4", NOTE_D4, "G4", NOTE_G4},

  // Register 4: Deep Bass (BTN_K4 - Pin 5)
  {"C3", NOTE_C3, "D3", NOTE_D3, "E3", NOTE_E3, "F3", NOTE_F3,
   "G2", NOTE_G2, "A2", NOTE_A2, "B2", NOTE_B2, "G3", NOTE_G3}
};

void setup() {
  pinMode(BTN_K1, INPUT_PULLUP);
  pinMode(BTN_K2, INPUT_PULLUP);
  pinMode(BTN_K3, INPUT_PULLUP);
  pinMode(BTN_K4, INPUT_PULLUP);
  u8g2.begin();
}

void drawUI(const NoteMap& m) {
  u8g2.firstPage();
  do {
    u8g2.setDrawColor(1);
    if (isInverted) u8g2.drawBox(0, 0, 128, 64);
    u8g2.setDrawColor(isInverted ? 0 : 1);

    // Title & Register Label
    u8g2.setFont(u8g2_font_5x7_tf);
    u8g2.drawStr(2, 8, "CYBER-SAX v1.5");
    u8g2.drawHLine(0, 10, 128);

    const char* regName = "LOW REGS";
    if (activeKeySet == 1) regName = "MID REGS (D11)";
    if (activeKeySet == 2) regName = "SHARPS (D9)";
    if (activeKeySet == 3) regName = "ALT REGS (D10)";
    if (activeKeySet == 4) regName = "BASS REGS (D5)";
    u8g2.drawStr(2, 20, regName);

    // Joystick Guide Visualization
    int cx = 85;
    int cy = 40;
    u8g2.drawCircle(cx, cy, 15);
    // Draw crosshair
    u8g2.drawLine(cx - 3, cy, cx + 3, cy);
    u8g2.drawLine(cx, cy - 3, cx, cy + 3);

    // Cardinal Labels
    u8g2.setFont(u8g2_font_4x6_tf);
    u8g2.drawStr(cx - 5, cy - 18, m.up);
    u8g2.drawStr(cx - 5, cy + 23, m.down);
    u8g2.drawStr(cx - 28, cy + 3, m.left);
    u8g2.drawStr(cx + 18, cy + 3, m.right);

    // Diagonal Labels
    u8g2.drawStr(cx + 12, cy - 12, m.ur);
    u8g2.drawStr(cx + 12, cy + 16, m.dr);
    u8g2.drawStr(cx - 26, cy - 12, m.ul);
    u8g2.drawStr(cx - 26, cy + 16, m.dl);

    // Current Playing Note Display
    u8g2.setFont(u8g2_font_7x14_tf);
    u8g2.drawStr(10, 45, "NOTE:");
    u8g2.drawStr(10, 60, currentNoteName);

    // Audio Wave Visualizer
    if (currentFreq > 0) {
      for (int i = 0; i < 30; i += 4) {
        int h = random(2, 15);
        u8g2.drawVLine(45 + i, 58 - h, h);
      }
    }

  } while (u8g2.nextPage());
}

void loop() {
  // 1. Determine active register based on buttons
  if (digitalRead(BTN_K4) == LOW) {
    activeKeySet = 4;
  } else if (digitalRead(BTN_K3) == LOW) {
    activeKeySet = 3;
  } else if (digitalRead(BTN_K2) == LOW) {
    activeKeySet = 2;
  } else if (digitalRead(BTN_K1) == LOW) {
    activeKeySet = 1;
  } else {
    activeKeySet = 0;
  }

  const NoteMap& m = registers[activeKeySet];

  // 2. Read Joystick for note selection
  int stickX = analogRead(STICK_X);
  int stickY = analogRead(STICK_Y);

  int newFreq = 0;
  const char* newName = "---";

  // Check stick position relative to center (512)
  bool isUp = stickY < (512 - JOYSTICK_DEADZONE);
  bool isDown = stickY > (512 + JOYSTICK_DEADZONE);
  bool isLeft = stickX < (512 - JOYSTICK_DEADZONE);
  bool isRight = stickX > (512 + JOYSTICK_DEADZONE);

  // Note Selection Logic (Including Diagonals)
  if (isUp && isRight)    { newFreq = m.urF; newName = m.ur; }
  else if (isDown && isRight) { newFreq = m.drF; newName = m.dr; }
  else if (isUp && isLeft)    { newFreq = m.ulF; newName = m.ul; }
  else if (isDown && isLeft)  { newFreq = m.dlF; newName = m.dl; }
  else if (isUp)              { newFreq = m.upF; newName = m.up; }
  else if (isDown)            { newFreq = m.downF; newName = m.down; }
  else if (isLeft)            { newFreq = m.leftF; newName = m.left; }
  else if (isRight)           { newFreq = m.rightF; newName = m.right; }

  // 3. Play Sound
  if (newFreq != currentFreq) {
    currentFreq = newFreq;
    currentNoteName = newName;
    if (currentFreq > 0) {
      tone(BZ_OUT, currentFreq);
    } else {
      noTone(BZ_OUT);
    }
  } else if (currentFreq > 0) {
    // Refresh tone in case button was changed while note sustained
    tone(BZ_OUT, currentFreq);
  }

  // 4. Update Display
  drawUI(m);
  
  delay(10); // Stability
}